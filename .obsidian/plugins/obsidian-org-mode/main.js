/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var codemirror = CodeMirror;

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  mod(codemirror);
})(function(CodeMirror) {

  CodeMirror.defineSimpleMode = function(name, states) {
    CodeMirror.defineMode(name, function(config) {
      return CodeMirror.simpleMode(config, states);
    });
  };

  CodeMirror.simpleMode = function(config, states) {
    ensureState(states, "start");
    var states_ = {}, meta = states.meta || {}, hasIndentation = false;
    for (var state in states) if (state != meta && states.hasOwnProperty(state)) {
      var list = states_[state] = [], orig = states[state];
      for (var i = 0; i < orig.length; i++) {
        var data = orig[i];
        list.push(new Rule(data, states));
        if (data.indent || data.dedent) hasIndentation = true;
      }
    }
    var mode = {
      startState: function() {
        return {state: "start", pending: null,
                local: null, localState: null,
                indent: hasIndentation ? [] : null};
      },
      copyState: function(state) {
        var s = {state: state.state, pending: state.pending,
                 local: state.local, localState: null,
                 indent: state.indent && state.indent.slice(0)};
        if (state.localState)
          s.localState = CodeMirror.copyState(state.local.mode, state.localState);
        if (state.stack)
          s.stack = state.stack.slice(0);
        for (var pers = state.persistentStates; pers; pers = pers.next)
          s.persistentStates = {mode: pers.mode,
                                spec: pers.spec,
                                state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                                next: s.persistentStates};
        return s;
      },
      token: tokenFunction(states_, config),
      innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },
      indent: indentFunction(states_, meta)
    };
    if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))
      mode[prop] = meta[prop];
    return mode;
  };

  function ensureState(states, name) {
    if (!states.hasOwnProperty(name))
      throw new Error("Undefined state " + name + " in simple mode");
  }

  function toRegex(val, caret) {
    if (!val) return /(?:)/;
    var flags = "";
    if (val instanceof RegExp) {
      if (val.ignoreCase) flags = "i";
      if (val.unicode) flags += "u";
      val = val.source;
    } else {
      val = String(val);
    }
    return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
  }

  function asToken(val) {
    if (!val) return null;
    if (val.apply) return val
    if (typeof val == "string") return val.replace(/\./g, " ");
    var result = [];
    for (var i = 0; i < val.length; i++)
      result.push(val[i] && val[i].replace(/\./g, " "));
    return result;
  }

  function Rule(data, states) {
    if (data.next || data.push) ensureState(states, data.next || data.push);
    this.regex = toRegex(data.regex);
    this.token = asToken(data.token);
    this.data = data;
  }

  function tokenFunction(states, config) {
    return function(stream, state) {
      if (state.pending) {
        var pend = state.pending.shift();
        if (state.pending.length == 0) state.pending = null;
        stream.pos += pend.text.length;
        return pend.token;
      }

      if (state.local) {
        if (state.local.end && stream.match(state.local.end)) {
          var tok = state.local.endToken || null;
          state.local = state.localState = null;
          return tok;
        } else {
          var tok = state.local.mode.token(stream, state.localState), m;
          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
            stream.pos = stream.start + m.index;
          return tok;
        }
      }

      var curState = states[state.state];
      for (var i = 0; i < curState.length; i++) {
        var rule = curState[i];
        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
        if (matches) {
          if (rule.data.next) {
            state.state = rule.data.next;
          } else if (rule.data.push) {
            (state.stack || (state.stack = [])).push(state.state);
            state.state = rule.data.push;
          } else if (rule.data.pop && state.stack && state.stack.length) {
            state.state = state.stack.pop();
          }

          if (rule.data.mode)
            enterLocalMode(config, state, rule.data.mode, rule.token);
          if (rule.data.indent)
            state.indent.push(stream.indentation() + config.indentUnit);
          if (rule.data.dedent)
            state.indent.pop();
          var token = rule.token;
          if (token && token.apply) token = token(matches);
          if (matches.length > 2 && rule.token && typeof rule.token != "string") {
            for (var j = 2; j < matches.length; j++)
              if (matches[j])
                (state.pending || (state.pending = [])).push({text: matches[j], token: rule.token[j - 1]});
            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
            return token[0];
          } else if (token && token.join) {
            return token[0];
          } else {
            return token;
          }
        }
      }
      stream.next();
      return null;
    };
  }

  function cmp(a, b) {
    if (a === b) return true;
    if (!a || typeof a != "object" || !b || typeof b != "object") return false;
    var props = 0;
    for (var prop in a) if (a.hasOwnProperty(prop)) {
      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;
      props++;
    }
    for (var prop in b) if (b.hasOwnProperty(prop)) props--;
    return props == 0;
  }

  function enterLocalMode(config, state, spec, token) {
    var pers;
    if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)
      if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;
    var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);
    var lState = pers ? pers.state : CodeMirror.startState(mode);
    if (spec.persistent && !pers)
      state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};

    state.localState = lState;
    state.local = {mode: mode,
                   end: spec.end && toRegex(spec.end),
                   endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
                   endToken: token && token.join ? token[token.length - 1] : token};
  }

  function indexOf(val, arr) {
    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;
  }

  function indentFunction(states, meta) {
    return function(state, textAfter, line) {
      if (state.local && state.local.mode.indent)
        return state.local.mode.indent(state.localState, textAfter, line);
      if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)
        return CodeMirror.Pass;

      var pos = state.indent.length - 1, rules = states[state.state];
      scan: for (;;) {
        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i];
          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
            var m = rule.regex.exec(textAfter);
            if (m && m[0]) {
              pos--;
              if (rule.next || rule.push) rules = states[rule.next || rule.push];
              textAfter = textAfter.slice(m[0].length);
              continue scan;
            }
          }
        }
        break;
      }
      return pos < 0 ? 0 : state.indent[pos];
    };
  }
});
});

createCommonjsModule(function (module, exports) {
(function(mod) {
    mod(codemirror);
})(function(CodeMirror) {
    CodeMirror.registerHelper("fold", "orgmode", function(cm, start) {
        // init
        const levelToMatch = headerLevel(start.line);

        // no folding needed
        if(levelToMatch === null) return;

        // find folding limits
        const lastLine = cm.lastLine();
        let end = start.line;
        while(end < lastLine){
            end += 1;
            let level = headerLevel(end);
            if(level && level <= levelToMatch) {
                end = end - 1;
                break;
            }        }

        return {
            from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
            to: CodeMirror.Pos(end, cm.getLine(end).length)
        };

        function headerLevel(lineNo) {
            var line = cm.getLine(lineNo);
            var match = /^\*+/.exec(line);
            if(match && match.length === 1 && /header/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)))){
                return match[0].length;
            }
            return null;
        }
    });
    CodeMirror.registerGlobalHelper("fold", "drawer", function(mode) {
        return mode.name === 'orgmode' ? true : false;
    }, function(cm, start) {
        const drawer = isBeginningOfADrawer(start.line);
        if(drawer === false) return;

        // find folding limits
        const lastLine = cm.lastLine();
        let end = start.line;
        while(end < lastLine){
            end += 1;
            if(isEndOfADrawer(end)){
                break;
            }
        }

        return {
            from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
            to: CodeMirror.Pos(end, cm.getLine(end).length)
        };

        function isBeginningOfADrawer(lineNo) {
            var line = cm.getLine(lineNo);
            var match = /^\:.*\:$/.exec(line);
            if(match && match.length === 1 && match[0] !== ':END:'){
                return true;
            }
            return false;
        }
        function isEndOfADrawer(lineNo){
            var line = cm.getLine(lineNo);
            return line.trim() === ':END:' ? true : false;
        }
    });
});
});

createCommonjsModule(function (module, exports) {
(function(mod) {
    mod(codemirror);
})(function(CodeMirror) {

    CodeMirror.defineSimpleMode("orgmode", {
        start: [
            {regex: /(\*\s)(TODO|DOING|WAITING|NEXT|PENDING|)(CANCELLED|CANCELED|CANCEL|DONE|REJECTED|STOP|STOPPED|)(\s+\[\#[A-C]\]\s+|)(.*?)(?:(\s{10,}|))(\:[\S]+\:|)$/, sol: true, token: ["header level1 org-level-star","header level1 org-todo","header level1 org-done", "header level1 org-priority", "header level1", "header level1 void", "header level1 comment"]},
            {regex: /(\*{1,}\s)(TODO|DOING|WAITING|NEXT|PENDING|)(CANCELLED|CANCELED|CANCEL|DEFERRED|DONE|REJECTED|STOP|STOPPED|)(\s+\[\#[A-C]\]\s+|)(.*?)(?:(\s{10,}|))(\:[\S]+\:|)$/, sol: true, token: ["header org-level-star","header org-todo","header org-done", "header org-priority", "header", "header void", "header comment"]},
            {regex: /(\+[^\+]+\+)/, token: ["strikethrough"]},
            {regex: /(\*[^\*]+\*)/, token: ["strong"]},
            {regex: /(\/[^\/]+\/)/, token: ["em"]},
            {regex: /(\_[^\_]+\_)/, token: ["link"]},
            {regex: /(\~[^\~]+\~)/, token: ["comment"]},
            {regex: /(\=[^\=]+\=)/, token: ["comment"]},
            {regex: /\[\[[^\[\]]+\]\[[^\[\]]+\]\]/, token: "org-url"}, // links
            {regex: /\[\[[^\[\]]+\]\]/, token: "org-image"}, // image
            {regex: /\[[xX\s\-\_]\]/, token: 'qualifier org-toggle'}, // checkbox
            {regex: /\#\+(?:(BEGIN|begin))_[a-zA-Z]*/, token: "comment", next: "env", sol: true}, // comments
            {regex: /:?[A-Z_]+\:.*/, token: "comment", sol: true}, // property drawers
            {regex: /(\#\+[a-zA-Z_]*)(\:.*)/, token: ["keyword", 'qualifier'], sol: true}, // environments
            {regex: /(CLOCK\:|SHEDULED\:|DEADLINE\:)(\s.+)/, token: ["comment", "keyword"]}
        ],
        env: [
            {regex: /\#\+(?:(END|end))_[a-zA-Z]*/, token: "comment", next: "start", sol: true},
            {regex: /.*/, token: "comment"}
        ]
    });


    CodeMirror.registerHelper("fold", "orgmode", function(cm, start) {
        // init
        const levelToMatch = headerLevel(start.line);

        // no folding needed
        if(levelToMatch === null) return;

        // find folding limits
        const lastLine = cm.lastLine();
        let end = start.line;
        while(end < lastLine){
            end += 1;
            let level = headerLevel(end);
            if(level && level <= levelToMatch) {
                end = end - 1;
                break;
            }        }

        return {
            from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
            to: CodeMirror.Pos(end, cm.getLine(end).length)
        };

        function headerLevel(lineNo) {
            var line = cm.getLine(lineNo);
            var match = /^\*+/.exec(line);
            if(match && match.length === 1 && /header/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)))){
                return match[0].length;
            }
            return null;
        }
    });
    CodeMirror.registerGlobalHelper("fold", "drawer", function(mode) {
        return mode.name === 'orgmode' ? true : false;
    }, function(cm, start) {
        const drawer = isBeginningOfADrawer(start.line);
        if(drawer === false) return;

        // find folding limits
        const lastLine = cm.lastLine();
        let end = start.line;
        while(end < lastLine){
            end += 1;
            if(isEndOfADrawer(end)){
                break;
            }
        }

        return {
            from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
            to: CodeMirror.Pos(end, cm.getLine(end).length)
        };

        function isBeginningOfADrawer(lineNo) {
            var line = cm.getLine(lineNo);
            var match = /^\:.*\:$/.exec(line);
            if(match && match.length === 1 && match[0] !== ':END:'){
                return true;
            }
            return false;
        }
        function isEndOfADrawer(lineNo){
            var line = cm.getLine(lineNo);
            return line.trim() === ':END:' ? true : false;
        }
    });


    CodeMirror.registerHelper("orgmode", "init", (editor, fn) => {
        editor.setOption("extraKeys", {
            "Tab": function(cm) { org_cycle(cm); },
            "Shift-Tab": function(cm){ fn('shifttab', org_shifttab(cm)); },
            "Alt-Left": function(cm){ org_metaleft(cm); },
            "Alt-Right": function(cm){ org_metaright(cm); },
            "Alt-Enter": function(cm){ org_meta_return(cm); },
            "Alt-Up": function(cm){ org_metaup(cm); },
            "Alt-Down": function(cm){ org_metadown(cm); },
            "Shift-Alt-Left": function(cm){ org_shiftmetaleft(cm); },
            "Shift-Alt-Right": function(cm){ org_shiftmetaright(cm); },
            "Shift-Alt-Enter": function(cm){ org_insert_todo_heading(cm); },
            "Shift-Left": function(cm){ org_shiftleft(cm); },
            "Shift-Right": function(cm){ org_shiftright(cm); }
        });
        fn('shifttab', org_set_fold(editor));

        editor.on('mousedown', toggleHandler);
        editor.on('touchstart', toggleHandler);
        editor.on('gutterClick', foldLine);

        // fold everything except headers by default
        editor.operation(function() {
            for (var i = 0; i < editor.lineCount() ; i++) {
                if(/header/.test(editor.getTokenTypeAt(CodeMirror.Pos(i, 0))) === false){
                    fold(editor, CodeMirror.Pos(i, 0));
                }
            }
        });
        return CodeMirror.orgmode.destroy.bind(this, editor);
    });

    CodeMirror.registerHelper("orgmode", "destroy", (editor) => {
        editor.off('mousedown', toggleHandler);
        editor.off('touchstart', toggleHandler);
        editor.off('gutterClick', foldLine);
    });

    function foldLine(cm, line){
        const cursor = {line: line, ch: 0};
        isFold(cm, cursor) ? unfold(cm, cursor) : fold(cm, cursor);
    }


    let widgets = [];
    function toggleHandler(cm, e){
        const position = cm.coordsChar({
            left: e.clientX || (e.targetTouches && e.targetTouches[0].clientX),
            top: e.clientY || (e.targetTouches && e.targetTouches[0].clientY)
        }, "page"),
              token = cm.getTokenAt(position);

        _disableSelection();
        if(/org-level-star/.test(token.type)){
            _preventIfShould();
            _foldHeadline();
            _disableSelection();
        }else if(/org-toggle/.test(token.type)){
            _preventIfShould();
            _toggleCheckbox();
            _disableSelection();
        }else if(/org-todo/.test(token.type)){
            _preventIfShould();
            _toggleTodo();
            _disableSelection();
        }else if(/org-done/.test(token.type)){
            _preventIfShould();
            _toggleDone();
            _disableSelection();
        }else if(/org-priority/.test(token.type)){
            _preventIfShould();
            _togglePriority();
            _disableSelection();
        }else if(/org-url/.test(token.type)){
            _disableSelection();
            _navigateLink();
        }else if(/org-image/.test(token.type)){
            _disableSelection();
            _toggleImageWidget();
        }

        function _preventIfShould(){
            if('ontouchstart' in window) e.preventDefault();
        }
        function _disableSelection(){
            cm.on('beforeSelectionChange', _onSelectionChangeHandler);
            function _onSelectionChangeHandler(cm, obj){
                obj.update([{
                    anchor: position,
                    head: position
                }]);
                cm.off('beforeSelectionChange', _onSelectionChangeHandler);
            }
        }

        function _foldHeadline(){
            const line = position.line;
            if(line >= 0){
                const cursor = {line: line, ch: 0};
                isFold(cm, cursor) ? unfold(cm, cursor) : fold(cm, cursor);
            }
        }

        function _toggleCheckbox(){
            const line = position.line;
            const content = cm.getRange({line: line, ch: token.start}, {line: line, ch: token.end});
            let new_content = content === "[X]" || content === "[x]" ? "[ ]" : "[X]";
            cm.replaceRange(new_content, {line: line, ch: token.start}, {line: line, ch: token.end});
        }

        function _toggleTodo(){
            const line = position.line;
            cm.replaceRange("DONE", {line: line, ch: token.start}, {line: line, ch: token.end});
        }

        function _toggleDone(){
            const line = position.line;
            cm.replaceRange("TODO", {line: line, ch: token.start}, {line: line, ch: token.end});
        }

        function _togglePriority(){
            const PRIORITIES = [" [#A] ", " [#B] ", " [#C] ", " [#A] "];
            const line = position.line;
            const content = cm.getRange({line: line, ch: token.start}, {line: line, ch: token.end});
            let new_content = PRIORITIES[PRIORITIES.indexOf(content) + 1];
            cm.replaceRange(new_content, {line: line, ch: token.start}, {line: line, ch: token.end});
        }

        function _toggleImageWidget(){
            let exist = !!widgets
                .filter((line) => line === position.line)[0];

            if(exist === false){
                if(!token.string.match(/\[\[(.*)\]\]/)) return null;
                let $node = _buildImage(RegExp.$1);
                const widget = cm.addLineWidget(position.line, $node, {coverGutter: false});
                widgets.push(position.line);
                $node.addEventListener('click', closeWidget);

                function closeWidget(){
                    widget.clear();
                    $node.removeEventListener('click', closeWidget);
                    widgets = widgets.filter((line) => line !== position.line);
                }
            }
            function _buildImage(src){
                let $el = document.createElement("div");
                let $img = document.createElement("img");

                if(/^https?\:\/\//.test(src)){
                    $img.src = src;
                }else {
                    const root_path = dirname(window.location.pathname.replace(/^\/view/, ''));
                    const img_path = src;
                    $img.src = "/api/files/cat?path="+encodeURIComponent(pathBuilder(root_path, img_path));
                }
                $el.appendChild($img);
                return $el;
            }
            return null;
        }

        function _navigateLink(){
            token.string.match(/\[\[(.*?)\]\[/);
            const link = RegExp.$1;
            if(!link) return;

            if(/^https?\:\/\//.test(link)){
                window.open(link);
            }else {
                const root_path = dirname(window.location.pathname.replace(/^\/view/, ''));
                const link_path = link;
                window.open("/view"+pathBuilder(root_path, link_path));
            }
        }
    }

    CodeMirror.defineMIME("text/org", "org");
});
});

class OrgMode extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.orgViewCreator = (leaf) => {
            return new OrgView(leaf);
        };
    }
    onload() {
        const _super = Object.create(null, {
            onload: { get: () => super.onload }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.onload.call(this);
            console.log("Loading Org Mode plugin ...");
            this.registerView("orgmode", this.orgViewCreator);
            this.registerExtensions(["org", "org_archive"], "orgmode");
        });
    }
    onunload() {
        console.log("Unloading Org Mode plugin ...");
    }
}
// This is the custom view:
class OrgView extends obsidian.TextFileView {
    // this.contentEl is not exposed, so cheat a bit.
    get extContentEl() {
        // @ts-ignore
        return this.contentEl;
    }
    constructor(leaf) {
        super(leaf);
        this.changed = () => __awaiter(this, void 0, void 0, function* () {
            this.requestSave();
        });
        this.getViewData = () => {
            return this.codeMirror.getValue();
        };
        this.setViewData = (data, clear) => {
            var _a, _b, _c;
            if (clear) {
                // @ts-ignore
                this.codeMirror.swapDoc(CodeMirror.Doc(data, "orgmode"));
            }
            else {
                this.codeMirror.setValue(data);
            }
            // @ts-ignore
            if ((_c = (_b = (_a = this.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.vimMode) {
                this.codeMirror.setOption("keyMap", "vim");
            }
            // This seems to fix some odd visual bugs:
            this.codeMirror.refresh();
            // This focuses the editor, which is analogous to the
            // default Markdown behavior in Obsidian:
            this.codeMirror.focus();
        };
        this.clear = () => {
            this.codeMirror.setValue("");
            this.codeMirror.clearHistory();
        };
        // @ts-ignore
        this.codeMirror = CodeMirror(this.extContentEl);
        this.codeMirror.on("changes", this.changed);
    }
    // When the view is resized, refresh CodeMirror (thanks Licat!).
    onResize() {
        this.codeMirror.refresh();
    }
    getDisplayText() {
        if (this.file) {
            return this.file.basename;
        }
        else {
            return "org (No File)";
        }
    }
    canAcceptExtension(extension) {
        return extension === "org" || extension === "org_archive";
    }
    getViewType() {
        return "orgmode";
    }
}

module.exports = OrgMode;


/* nosourcemap */